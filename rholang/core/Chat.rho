new result(`rho:io:stdout`), stdout(`rho:io:stdout`), chat in {
new insertArbitrary(`rho:registry:insertArbitrary`), uriCh in {
    insertArbitrary!(bundle+{*chat}, *uriCh) | 
    for(@uri <- uriCh) {
    stdout!(["#define $Chat", uri])
//  |
//    deployId!(uri)
    }
} | 
  result!("starting") |
  contract chat(ret) = {
    new head, tail, pub, sub, nextCh in {
      tail!(*head) |
      nextCh!(*head) |
      ret!(*pub, *sub) |
      new isEnd in
      contract sub(listener, endCap) = {
        contract isEnd(ret) = {
          for (next <<- nextCh) {
            for (end <<- tail) {
              ret!(*end == *next)
            }
          }
        } | endCap!(*isEnd) |
        new loop, ack in {
          loop!(*head) |
          contract loop(curr) = {
            for (message, next <<- curr) {
              listener!(*message, *ack) |
              stdout!(["got next",*message]) |
              result!("listener called for " ++ *message) |
              for ( _ <- ack) {
                result!(["sent",*message]) |
                stdout!(["sent",*message]) |
                loop!(*next)
              }
            }
          }
        }
      } |
      contract pub(msg, ack) = {
        new newTail, ack1 in {
          for (end <- tail) {
            end!(*msg, *newTail) |
            tail!(*newTail) |
            stdout!("pub: " ++ *msg)
          }|
          ack!(Nil)
        }
      } 
    }
  } |
  result!("testing") |
  new listener, ret, logList, ack, theEnd in {
    contract listener(message, ret) = {
      stdout!(*message ++ " listener")|
      //stdout!(*message ) |
      //for ( _ <- ack ) {
        ret!(Nil)
      //}
    } |

    chat!(*ret) |
    for ( pub, sub <- ret) {
      stdout!("got chat")|
      sub!(*listener, *theEnd) |
      pub!("one",*ret) |
      for ( _ <- ret) {
        stdout!("pub one")|
        pub!("two", *ret) |
        for ( _ <- ret ) {
          pub!("three", *ret) |
          for ( _ <- ret ) {
            pub!("four", *ret) |
            for ( _ <- ret ) {
              stdout!("done") //|
              // for (_ <- ret; alist <- logList ) {
              //   stdout!(*alist)|
              //   result!({ "log":*alist}) |
              //   logList!(*alist)|
                
              // }
            }
          }
        }
      }
    } //|
    // logList!([]) |
    // contract log(message, ack) = {
    //   for ( prior <- logList) {
    //     stdout!("logged: " ++ *message) |
    //     logList!(*prior ++ [*message]) |
    //     //for ( _ <<- logList) {
    //       stdout!("log ack")|
    //       ack!(Nil)
    //     //}
    //   }
    // }
  }
}